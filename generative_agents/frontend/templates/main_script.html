<script type="text/javascript">
	/* eslint-disable */
	/* 
	 * This is a Jinja2 template file that contains server-side template syntax.
	 * IDE linter errors are expected and can be ignored as the syntax will be
	 * properly rendered by the Flask/Jinja2 template engine on the server side.
	 */
	// Initialize variables from Flask context (wrap Jinja JSON in a string to satisfy static analyzers)
	const FLASK_CTX_JSON = `{
		"step": {{ step|tojson }},
		"sec_per_step": {{ sec_per_step|tojson }},
		"zoom": {{ zoom|tojson }},
		"play_speed": {{ play_speed|tojson }},
		"all_movement": {{ all_movement|tojson }},
		"start_datetime": {{ start_datetime|tojson }},
		"persona_init_pos": {{ persona_init_pos|tojson }}
	}`;
	const FLASK = JSON.parse(FLASK_CTX_JSON);

	let step = FLASK.step;
	let step_size = FLASK.sec_per_step * 1000; // Convert to milliseconds
	let zoom = FLASK.zoom;
	if (zoom <= 0) zoom = document.documentElement.clientWidth / 4400;

	let tile_width = 32;
	let movement_speed = FLASK.play_speed;
	let execute_count_max = tile_width / movement_speed;
	let execute_count = execute_count_max;
	let all_movement = FLASK.all_movement;

	let datetime_options = { weekday: "long", year: "numeric", month: "long", day: "numeric" };
	let start_datetime = new Date(Date.parse(FLASK.start_datetime));

	// Persona related variables
	let persona_names = FLASK.persona_init_pos;
	var spawn_tile_loc = {};
	for (var key in persona_names) {
		spawn_tile_loc[key] = persona_names[key];
	}

	var personas = {};
	var pronunciatios = {};
	var nameLabels = {};
	let anims_direction;
	let pre_anims_direction;
	let pre_anims_direction_dict = {};

	let movement_target = {};
	let currentTime;

	// è‡ªåŠ¨æ‘„åƒæœºå·¡èˆªä¸å»ºé€ é…ç½®
	let autoCameraEnabled = true;
	let autoBuildEnabled = true;
	let autoMoveSeconds = 12;
	let autoReturnSeconds = 8;
	let autoState = 'idle_base'; // idle_base | moving_out | at_target | moving_back
	let autoNextActionAt = performance.now() + autoMoveSeconds * 1000;
	let autoBasePos = { x: 2440, y: 500 };
	let autoTargetPos = null;
	let sceneRef = null;
	let mapRef = null;
	let layersRef = {};




	// Phaser configuration
	const config = {
		type: Phaser.AUTO,
		width: 4480,
		height: 3200,
		parent: "game-container",
		pixelArt: true,
		physics: {
			default: "arcade",
			arcade: {
				gravity: { y: 0 }
			}
		},
		scene: {
			preload: preload,
			create: create,
			update: update
		},
		scale: {
			mode: Phaser.Scale.FIT,
			autoCenter: Phaser.Scale.CENTER_BOTH,
			zoom: zoom
		}
	};

	// Create Phaser game instance
	const game = new Phaser.Game(config);
	let cursors;
	let player;

	// Preload function
	function preload() {
		this.load.crossOrigin = "";

		// Load images
		this.load.image("blocks_1", "static/assets/village/tilemap/blocks_1.png");
		this.load.image("walls", "static/assets/village/tilemap/Room_Builder_32x32.png");
		this.load.image("interiors_pt1", "static/assets/village/tilemap/interiors_pt1.png");
		this.load.image("interiors_pt2", "static/assets/village/tilemap/interiors_pt2.png");
		this.load.image("interiors_pt3", "static/assets/village/tilemap/interiors_pt3.png");
		this.load.image("interiors_pt4", "static/assets/village/tilemap/interiors_pt4.png");
		this.load.image("interiors_pt5", "static/assets/village/tilemap/interiors_pt5.png");
		this.load.image("CuteRPG_Field_B", "static/assets/village/tilemap/CuteRPG_Field_B.png");
		this.load.image("CuteRPG_Field_C", "static/assets/village/tilemap/CuteRPG_Field_C.png");
		this.load.image("CuteRPG_Harbor_C", "static/assets/village/tilemap/CuteRPG_Harbor_C.png");
		this.load.image("CuteRPG_Village_B", "static/assets/village/tilemap/CuteRPG_Village_B.png");
		this.load.image("CuteRPG_Forest_B", "static/assets/village/tilemap/CuteRPG_Forest_B.png");
		this.load.image("CuteRPG_Desert_C", "static/assets/village/tilemap/CuteRPG_Desert_C.png");
		this.load.image("CuteRPG_Mountains_B", "static/assets/village/tilemap/CuteRPG_Mountains_B.png");
		this.load.image("CuteRPG_Desert_B", "static/assets/village/tilemap/CuteRPG_Desert_B.png");
		this.load.image("CuteRPG_Forest_C", "static/assets/village/tilemap/CuteRPG_Forest_C.png");

		// å»ºç­‘å›¾é›†ï¼ˆç”¨äºæ”¾ç½®çœŸå®å»ºç­‘ç“¦ç‰‡ï¼‰
		this.load.image("AI_Buildings", "static/assets/village/tilemap/AI_Buildings.png");

		// Load tilemap JSON
		this.load.tilemapTiledJSON("map", "static/assets/village/tilemap/tilemap_patched.json");

		// Load a default atlas (example persona)
		this.load.atlas("atlas", "static/assets/village/agents/ä¼Šèè´æ‹‰/texture.png", "static/assets/village/agents/sprite.json");

		// Load persona atlases
		for (var p in persona_names) {
			let image_static = "static/assets/village/agents/" + p + "/texture.png";
			this.load.atlas(p, image_static, "static/assets/village/agents/sprite.json");
		}
	}

	// Create function
	function create() {
		const map = this.make.tilemap({ key: "map" });

		// Add tilesets and layers
		const collisions = map.addTilesetImage("blocks", "blocks_1");
		const walls = map.addTilesetImage("Room_Builder_32x32", "walls");
		const interiors_pt1 = map.addTilesetImage("interiors_pt1", "interiors_pt1");
		const interiors_pt2 = map.addTilesetImage("interiors_pt2", "interiors_pt2");
		const interiors_pt3 = map.addTilesetImage("interiors_pt3", "interiors_pt3");
		const interiors_pt4 = map.addTilesetImage("interiors_pt4", "interiors_pt4");
		const interiors_pt5 = map.addTilesetImage("interiors_pt5", "interiors_pt5");
		const CuteRPG_Field_B = map.addTilesetImage("CuteRPG_Field_B", "CuteRPG_Field_B");
		const CuteRPG_Field_C = map.addTilesetImage("CuteRPG_Field_C", "CuteRPG_Field_C");
		const CuteRPG_Harbor_C = map.addTilesetImage("CuteRPG_Harbor_C", "CuteRPG_Harbor_C");
		const CuteRPG_Village_B = map.addTilesetImage("CuteRPG_Village_B", "CuteRPG_Village_B");
		const CuteRPG_Forest_B = map.addTilesetImage("CuteRPG_Forest_B", "CuteRPG_Forest_B");
		const CuteRPG_Desert_C = map.addTilesetImage("CuteRPG_Desert_C", "CuteRPG_Desert_C");
		const CuteRPG_Mountains_B = map.addTilesetImage("CuteRPG_Mountains_B", "CuteRPG_Mountains_B");
		const CuteRPG_Desert_B = map.addTilesetImage("CuteRPG_Desert_B", "CuteRPG_Desert_B");
		const CuteRPG_Forest_C = map.addTilesetImage("CuteRPG_Forest_C", "CuteRPG_Forest_C");

		let tileset_group_1 = [CuteRPG_Field_B, CuteRPG_Field_C, CuteRPG_Harbor_C, CuteRPG_Village_B,
			CuteRPG_Forest_B, CuteRPG_Desert_C, CuteRPG_Mountains_B, CuteRPG_Desert_B, CuteRPG_Forest_C,
			interiors_pt1, interiors_pt2, interiors_pt3, interiors_pt4, interiors_pt5, walls];
		const bottomGroundLayer = map.createLayer("Bottom Ground", tileset_group_1, 0, 0);
		const exteriorGroundLayer = map.createLayer("Exterior Ground", tileset_group_1, 0, 0);
		const exteriorDecorationL1Layer = map.createLayer("Exterior Decoration L1", tileset_group_1, 0, 0);
		const exteriorDecorationL2Layer = map.createLayer("Exterior Decoration L2", tileset_group_1, 0, 0);
		const interiorGroundLayer = map.createLayer("Interior Ground", tileset_group_1, 0, 0);
		const wallLayer = map.createLayer("Wall", [CuteRPG_Field_C, walls], 0, 0);
		const interiorFurnitureL1Layer = map.createLayer("Interior Furniture L1", tileset_group_1, 0, 0);
		const interiorFurnitureL2Layer = map.createLayer("Interior Furniture L2 ", tileset_group_1, 0, 0);
		const foregroundL1Layer = map.createLayer("Foreground L1", tileset_group_1, 0, 0);
		const foregroundL2Layer = map.createLayer("Foreground L2", tileset_group_1, 0, 0);

		const collisionsLayer = map.createLayer("Collisions", collisions, 0, 0);

		collisionsLayer.setCollisionByProperty({ collide: true });

		collisionsLayer.setDepth(-1);
		foregroundL1Layer.setDepth(2);
		foregroundL2Layer.setDepth(2);

		const canvas = game.canvas;
		canvas.addEventListener("wheel", (event) => {
			event.preventDefault();
			
			// è·å–å½“å‰camera
			const camera = game.scene.scenes[0].cameras.main;
			const zoomFactor = 0.1;
			const minZoom = 0.2;
			const maxZoom = 2.0;
			
			// æ ¹æ®æ»šè½®æ–¹å‘è°ƒæ•´zoom
			if (event.deltaY < 0) {
				// å‘ä¸Šæ»šåŠ¨ï¼Œæ”¾å¤§
				camera.zoom = Math.min(camera.zoom + zoomFactor, maxZoom);
			} else {
				// å‘ä¸‹æ»šåŠ¨ï¼Œç¼©å°
				camera.zoom = Math.max(camera.zoom - zoomFactor, minZoom);
			}
		}, { passive: false, capture: true });

		function add_text(game, x, y, text, background) {
			const res = game.add.text(
				x,
				y,
				text,
				{
					font: "24px é»‘ä½“",
					fontWeight: "normal",
					fill: "#000000",
					backgroundColor: background,
					padding: { x: 20, y: 4},
					align: "left",
					wordWrap: { width: 1200/zoom, useAdvancedWrap: true },
				}
			);

			res.setDepth(10);
			res.alpha = 0.8;
			res.setScrollFactor(0);

			return res;
		}

		let posX = 20;
		let posY = 20;





		// Show current time
		currentTime = add_text(this, 20, 20, "", "#ccffcc");

		// Setup camera
		player = this.physics.add.sprite(2440, 500, "atlas", "down").setSize(30, 40).setOffset(0, 0);
		player.setDepth(-1);
		const camera = this.cameras.main;
		camera.startFollow(player);
		camera.setBounds(0, 0, map.widthInPixels, map.heightInPixels);
		cursors = this.input.keyboard.createCursorKeys();

		// è®°å½•åœºæ™¯ä¸åœ°å›¾å¼•ç”¨ä¾›è‡ªåŠ¨å·¡èˆªä¸å»ºé€ ä½¿ç”¨
		sceneRef = this;
		mapRef = map;
		layersRef = {
			bottomGroundLayer,
			exteriorGroundLayer,
			exteriorDecorationL1Layer,
			exteriorDecorationL2Layer,
			interiorGroundLayer,
			wallLayer,
			interiorFurnitureL1Layer,
			interiorFurnitureL2Layer,
			foregroundL1Layer,
			foregroundL2Layer,
			collisionsLayer,
		};

		// Setup personas
		// We start by creating the game sprite objects.
		for (let i=0; i<Object.keys(spawn_tile_loc).length; i++) {
			let persona_name = Object.keys(spawn_tile_loc)[i];
			let start_pos = [spawn_tile_loc[persona_name][0] * tile_width + tile_width / 2, spawn_tile_loc[persona_name][1] * tile_width + tile_width];
			let new_sprite = this.physics.add.sprite(start_pos[0], start_pos[1], persona_name, "down").setSize(30, 40).setOffset(0, 0);
			// Scale up the sprite
			new_sprite.displayWidth = 40;
			new_sprite.scaleY = new_sprite.scaleX;

			// Here, we are creating the persona and its pronunciatio sprites.
			personas[persona_name] = new_sprite;
			pronunciatios[persona_name] = this.add.text(
				new_sprite.body.x - 15,
				new_sprite.body.y - 15 - 25,
				"",
				{
					font: "18px monospace",
					fill: "#000000",
					backgroundColor: "#ffffcc",
					padding: { x: 4, y: 4},
					border:"solid",
					borderRadius:"10px"
				}
			).setDepth(3);
			pronunciatios[persona_name].alpha = 0.7;
			
			// Create name label below the character
			nameLabels[persona_name] = this.add.text(
				new_sprite.body.x - 15,
				new_sprite.body.y + 32 + 5,
				persona_name.replace("_", " "),
				{
					font: "14px Arial",
					fill: "#ffffff",
					backgroundColor: "#000000",
					padding: { x: 6, y: 2},
					borderRadius: "8px"
				}
			).setDepth(3);
			nameLabels[persona_name].alpha = 0.8;
			nameLabels[persona_name].setOrigin(0.5, 0); // Center horizontally
		}

		// Create animations
		const anims = this.anims;
		for (let i = 0; i < Object.keys(persona_names).length; i++) {
			let persona_name = Object.keys(persona_names)[i];
			let left_walk_name = persona_name + "-left-walk";
			let right_walk_name = persona_name + "-right-walk";
			let down_walk_name = persona_name + "-down-walk";
			let up_walk_name = persona_name + "-up-walk";

			let frameRate = 4;
			if (movement_speed > 1) frameRate = 8;

			anims.create({
				key: left_walk_name,
				frames: anims.generateFrameNames(persona_name, { prefix: "left-walk.", start: 0, end: 3, zeroPad: 3 }),
				frameRate: frameRate,
				repeat: -1
			});

			anims.create({
				key: right_walk_name,
				frames: anims.generateFrameNames(persona_name, { prefix: "right-walk.", start: 0, end: 3, zeroPad: 3 }),
				frameRate: frameRate,
				repeat: -1
			});

			anims.create({
				key: down_walk_name,
				frames: anims.generateFrameNames(persona_name, { prefix: "down-walk.", start: 0, end: 3, zeroPad: 3 }),
				frameRate: frameRate,
				repeat: -1
			});

			anims.create({
				key: up_walk_name,
				frames: anims.generateFrameNames(persona_name, { prefix: "up-walk.", start: 0, end: 3, zeroPad: 3 }),
				frameRate: frameRate,
				repeat: -1
			});
		}
	}

	// Update function
	function update(time, delta) {




		// Move camera
		const camera_speed = 400;
		player.body.setVelocity(0);
		if (cursors.left.isDown) {
			player.body.setVelocityX(-camera_speed);
		}
		if (cursors.right.isDown) {
			player.body.setVelocityX(camera_speed);
		}
		if (cursors.up.isDown) {
			player.body.setVelocityY(-camera_speed);
		}
		if (cursors.down.isDown) {
			player.body.setVelocityY(camera_speed);
		}

		// è‡ªåŠ¨å·¡èˆªï¼šåœ¨æ— æŒ‰é”®æ“ä½œæ—¶æ§åˆ¶æ‘„åƒæœºè·Ÿéšçš„ç©å®¶ç§»åŠ¨
		const anyKey = cursors.left.isDown || cursors.right.isDown || cursors.up.isDown || cursors.down.isDown;
		if (!anyKey) {
			updateAutoCameraTour(delta, camera_speed);
		}
		
		// Zoom control with keyboard
		const camera = this.cameras.main;
		const zoomSpeed = 0.02;
		const minZoom = 0.2;
		const maxZoom = 2.0;
		
		// + é”®æ”¾å¤§ï¼Œ- é”®ç¼©å°
		if (this.input.keyboard.addKey('PLUS').isDown || this.input.keyboard.addKey('EQUALS').isDown) {
			camera.zoom = Math.min(camera.zoom + zoomSpeed, maxZoom);
		}
		if (this.input.keyboard.addKey('MINUS').isDown || this.input.keyboard.addKey('UNDERSCORE').isDown) {
			camera.zoom = Math.max(camera.zoom - zoomSpeed, minZoom);
		}
		
		// 0 é”®é‡ç½®zoom
		if (this.input.keyboard.addKey('ZERO').isDown) {
			camera.zoom = zoom; // é‡ç½®ä¸ºåˆå§‹zoomå€¼
		}





		const curr_datetime = new Date(start_datetime.getTime());
		const curr_year = curr_datetime.getFullYear().toString().padStart(4, "0");
		const curr_month = (curr_datetime.getMonth() + 1).toString().padStart(2, "0");
		const curr_day = curr_datetime.getDate().toString().padStart(2, "0");
		const curr_hour = curr_datetime.getHours().toString().padStart(2, "0");
		const curr_minute = curr_datetime.getMinutes().toString().padStart(2, "0");
		const conversation_key = `${curr_year}${curr_month}${curr_day}-${curr_hour}:${curr_minute}`;
		const conversation_key_text = all_movement["conversation"][conversation_key];
		if (conversation_key_text && conversation_key_text != "") {
			// å°†å¯¹è¯å†…å®¹å‘é€åˆ°å³ä¾§æ è€Œä¸æ˜¯æ˜¾ç¤ºåœ¨æ¸¸æˆç”»é¢ä¸Š
			addConversationToSidebar(conversation_key, conversation_key_text);
		}

		// Moving personas
		for (let i = 0; i < Object.keys(personas).length; i++) {
			let curr_persona_name = Object.keys(personas)[i];
			let curr_persona = personas[curr_persona_name];
			let curr_pronunciatio = pronunciatios[Object.keys(personas)[i]];

			if (step in all_movement) {
				if (curr_persona_name.replace("_", " ") in all_movement[step]) {
					if (execute_count == execute_count_max) {
						let curr_x = all_movement[step][curr_persona_name.replace("_", " ")]["movement"][0];
						let curr_y = all_movement[step][curr_persona_name.replace("_", " ")]["movement"][1];
						movement_target[curr_persona_name] = [curr_x * tile_width, curr_y * tile_width];

						let action = all_movement[step][curr_persona_name.replace("_", " ")]["action"];

					let act = action;
					// æ˜¾ç¤ºå®Œæ•´çš„å¯¹è¯å†…å®¹ï¼Œä½†é™åˆ¶é•¿åº¦ä»¥é€‚åº”æ¸¸æˆç”»é¢
					if (act.length > 25) {
						act = act.substring(0, 25) + "...";
					}
					pronunciatios[curr_persona_name].setText(curr_persona_name.replace("_", " ") + ": " + act);


					}

					if (execute_count > 0 && movement_target[curr_persona_name]) {
						if (curr_persona.body.x < movement_target[curr_persona_name][0]) {
							curr_persona.body.x += movement_speed;
							anims_direction = "r";
							pre_anims_direction = "r";
							pre_anims_direction_dict[curr_persona_name] = "r";
						} else if (curr_persona.body.x > movement_target[curr_persona_name][0]) {
							curr_persona.body.x -= movement_speed;
							anims_direction = "l";
							pre_anims_direction = "l";
							pre_anims_direction_dict[curr_persona_name] = "l";
						} else if (curr_persona.body.y < movement_target[curr_persona_name][1]) {
							curr_persona.body.y += movement_speed;
							anims_direction = "d";
							pre_anims_direction = "d";
							pre_anims_direction_dict[curr_persona_name] = "d";
						} else if (curr_persona.body.y > movement_target[curr_persona_name][1]) {
							curr_persona.body.y -= movement_speed;
							anims_direction = "u";
							pre_anims_direction = "u";
							pre_anims_direction_dict[curr_persona_name] = "u";
						} else {
							anims_direction = "";
						}

						curr_pronunciatio.x = curr_persona.body.x - 15;
						curr_pronunciatio.y = curr_persona.body.y - 15 - 25;
						
						// æ›´æ–°åå­—æ ‡ç­¾ä½ç½®
						if (nameLabels[curr_persona_name]) {
							nameLabels[curr_persona_name].x = curr_persona.body.x;
							nameLabels[curr_persona_name].y = curr_persona.body.y + 32 + 5;
						}

						let left_walk_name = curr_persona_name + "-left-walk";
						let right_walk_name = curr_persona_name + "-right-walk";
						let down_walk_name = curr_persona_name + "-down-walk";
						let up_walk_name = curr_persona_name + "-up-walk";

						if (anims_direction == "l") {
							curr_persona.anims.play(left_walk_name, true);
						} else if (anims_direction == "r") {
							curr_persona.anims.play(right_walk_name, true);
						} else if (anims_direction == "u") {
							curr_persona.anims.play(up_walk_name, true);
						} else if (anims_direction == "d") {
							curr_persona.anims.play(down_walk_name, true);
						}
					}
				}
			} else {
				if (pre_anims_direction_dict[curr_persona_name] == "l") curr_persona.setTexture(curr_persona_name, "left");
				else if (pre_anims_direction_dict[curr_persona_name] == "r") curr_persona.setTexture(curr_persona_name, "right");
				else if (pre_anims_direction_dict[curr_persona_name] == "u") curr_persona.setTexture(curr_persona_name, "up");
				else if (pre_anims_direction_dict[curr_persona_name] == "d") curr_persona.setTexture(curr_persona_name, "down");
				curr_persona.anims.stop();
			}
		}

		if (execute_count == 0) {
			for (let i = 0; i < Object.keys(personas).length; i++) {
				let curr_persona_name = Object.keys(personas)[i];
				let curr_persona = personas[curr_persona_name];
				if (movement_target[curr_persona_name]) {
					curr_persona.body.x = movement_target[curr_persona_name][0];
					curr_persona.body.y = movement_target[curr_persona_name][1];
					
					// æ›´æ–°åå­—æ ‡ç­¾ä½ç½®
					if (nameLabels[curr_persona_name]) {
						nameLabels[curr_persona_name].x = curr_persona.body.x;
						nameLabels[curr_persona_name].y = curr_persona.body.y + 32 + 5;
					}
				}
			}
			execute_count = execute_count_max + 1;
			step = step + 1;

			start_datetime = new Date(start_datetime.getTime() + step_size);
			currentTime.setText(start_datetime.toLocaleTimeString("zh-CN", datetime_options));
		}

		execute_count -= 1;
	}

	// é€‰å–éšæœºåœ°å›¾åæ ‡
	function pickRandomMapCoord() {
		if (!mapRef) return { x: autoBasePos.x, y: autoBasePos.y };
		const w = mapRef.widthInPixels;
		const h = mapRef.heightInPixels;
		const margin = 64; // é¿å…é è¿‘è¾¹ç•Œ
		const x = Math.floor(Math.random() * (w - margin * 2)) + margin;
		const y = Math.floor(Math.random() * (h - margin * 2)) + margin;
		return { x, y };
	}

	// åœ¨æŒ‡å®šä½ç½®ç”Ÿæˆç®€æ˜“å»ºç­‘è¦†ç›–å±‚ï¼ˆçŸ©å½¢+æ ‡ç­¾ï¼‰ï¼Œä½“ç°â€œå»ºé€ â€æ•ˆæœ
	function spawnBuildingOverlay(x, y) {
		if (!sceneRef) return;
		const rect = sceneRef.add.rectangle(x, y, 64, 64, 0x4CAF50, 0.35);
		rect.setStrokeStyle(2, 0x66BB6A, 0.9);
		rect.setDepth(1);
		const label = add_text(sceneRef, x - 26, y - 42, 'ğŸ  å»ºé€ ', '#223322');
		label.setDepth(2);
	}

	// ä½¿ç”¨ AI_Buildings å›¾é›†æ”¾ç½®çœŸå®å»ºç­‘ç“¦ç‰‡ï¼Œå¹¶è¿”å›æ ¼å­åæ ‡
	const buildingTileWidth = 32;
	const buildingTypes = ['house', 'farm', 'shop', 'factory', 'mine', 'park'];
	const buildingTileIndex = {
		// x, y ä¸ºåœ¨ AI_Buildings.png ä¸­çš„æ ¼å­åæ ‡ï¼ˆ32x32ï¼‰
		house: { tx: 0, ty: 0 },
		farm: { tx: 1, ty: 0 },
		shop: { tx: 2, ty: 0 },
		factory: { tx: 3, ty: 0 },
		mine: { tx: 4, ty: 0 },
		park: { tx: 5, ty: 0 }
	};

	function chooseRandomBuildingType() {
		return buildingTypes[Math.floor(Math.random() * buildingTypes.length)];
	}

	function placeBuildingTile(type, worldX, worldY) {
		if (!sceneRef) return { tileX: 0, tileY: 0 };
		const info = buildingTileIndex[type] || buildingTileIndex.house;
		const cropX = info.tx * buildingTileWidth;
		const cropY = info.ty * buildingTileWidth;
		// å¯¹é½åˆ°æœ€è¿‘çš„æ ¼å­ä¸­å¿ƒ
		const tileX = Math.floor(worldX / tile_width);
		const tileY = Math.floor(worldY / tile_width);
		const alignedX = tileX * tile_width + tile_width / 2;
		const alignedY = tileY * tile_width + tile_width / 2;
		const img = sceneRef.add.image(alignedX, alignedY, 'AI_Buildings');
		img.setCrop(cropX, cropY, buildingTileWidth, buildingTileWidth);
		img.setDepth(10);
		return { tileX, tileY };
	}

	function postTerrainEvent(type, tileX, tileY, agentName = 'ç³»ç»Ÿ') {
		const typeNameMap = {
			house: 'ä½å®…',
			farm: 'å†œåœº',
			shop: 'å•†é“º',
			factory: 'å·¥å‚',
			mine: 'çŸ¿åœº',
			park: 'å…¬å›­'
		};
		const payload = {
			type: 'building_construction',
			timestamp: new Date().toISOString(),
			description: `åœ¨ (${tileX}, ${tileY}) å»ºé€ äº† ${typeNameMap[type] || 'å»ºç­‘'}`,
			agent: agentName,
			location: { x: tileX, y: tileY },
			building: type
		};
		fetch('/api/terrain/events', {
			method: 'POST',
			headers: { 'Content-Type': 'application/json' },
			body: JSON.stringify(payload)
		}).then(() => {
			if (typeof loadTerrainEvents === 'function') {
				loadTerrainEvents();
			}
		}).catch(err => console.error('Post terrain event failed:', err));
	}

	function showAutoNavStatus(text) {
		const el = document.getElementById('autoNavStatus');
		if (el) el.textContent = `çŠ¶æ€ï¼š${text}`;
	}

	function readAutoNavConfigFromUI() {
		const toggle = document.getElementById('autoCameraToggle');
		const moveSec = document.getElementById('autoMoveSeconds');
		const returnSec = document.getElementById('autoReturnSeconds');
		const buildToggle = document.getElementById('autoBuildToggle');
		autoCameraEnabled = toggle ? toggle.checked : autoCameraEnabled;
		autoMoveSeconds = moveSec ? Math.max(2, Number(moveSec.value || autoMoveSeconds)) : autoMoveSeconds;
		autoReturnSeconds = returnSec ? Math.max(2, Number(returnSec.value || autoReturnSeconds)) : autoReturnSeconds;
		autoBuildEnabled = buildToggle ? buildToggle.checked : autoBuildEnabled;
	}

	function setupAutoNavControls() {
		const toggle = document.getElementById('autoCameraToggle');
		const moveSec = document.getElementById('autoMoveSeconds');
		const returnSec = document.getElementById('autoReturnSeconds');
		const buildToggle = document.getElementById('autoBuildToggle');
		const startBtn = document.getElementById('autoCameraStartButton');

		if (toggle) toggle.addEventListener('change', () => { readAutoNavConfigFromUI(); showAutoNavStatus(autoCameraEnabled ? 'è‡ªåŠ¨å·¡èˆªä¸­' : 'å·²å…³é—­'); });
		if (moveSec) moveSec.addEventListener('change', () => { readAutoNavConfigFromUI(); });
		if (returnSec) returnSec.addEventListener('change', () => { readAutoNavConfigFromUI(); });
		if (buildToggle) buildToggle.addEventListener('change', () => { readAutoNavConfigFromUI(); });
		if (startBtn) startBtn.addEventListener('click', () => {
			readAutoNavConfigFromUI();
			autoState = 'idle_base';
			autoNextActionAt = performance.now() + autoMoveSeconds * 1000;
			showAutoNavStatus('å¾…å‘½');
		});

		readAutoNavConfigFromUI();
		showAutoNavStatus(autoCameraEnabled ? 'è‡ªåŠ¨å·¡èˆªä¸­' : 'å·²å…³é—­');
	}

	function updateAutoCameraTour(delta, camera_speed) {
		if (!autoCameraEnabled || !player) return;
		const now = performance.now();
		const dist = (a, b) => Math.hypot(a.x - b.x, a.y - b.y);
		const moveTowards = (src, dst) => {
			const dx = dst.x - src.x;
			const dy = dst.y - src.y;
			const d = Math.hypot(dx, dy) || 1;
			player.body.setVelocity((dx / d) * camera_speed, (dy / d) * camera_speed);
		};

		if (autoState === 'idle_base') {
			if (now >= autoNextActionAt) {
				autoTargetPos = pickRandomMapCoord();
				autoState = 'moving_out';
				showAutoNavStatus('å‰å¾€æ–°åŒºåŸŸ');
			}
			return;
		}
		if (autoState === 'moving_out') {
			moveTowards(player.body, autoTargetPos);
			if (dist(player.body, autoTargetPos) < 12) {
				player.body.setVelocity(0, 0);
				autoState = 'at_target';
				if (autoBuildEnabled) {
					const btype = chooseRandomBuildingType();
					const placed = placeBuildingTile(btype, autoTargetPos.x, autoTargetPos.y);
					postTerrainEvent(btype, placed.tileX, placed.tileY);
				}
				autoNextActionAt = now + autoReturnSeconds * 1000;
				showAutoNavStatus('æŠµè¾¾ï¼Œå»ºè®¾ä¸­');
			}
			return;
		}
		if (autoState === 'at_target') {
			if (now >= autoNextActionAt) {
				autoState = 'moving_back';
				showAutoNavStatus('è¿”å›åŸºåœ°');
			}
			return;
		}
		if (autoState === 'moving_back') {
			moveTowards(player.body, autoBasePos);
			if (dist(player.body, autoBasePos) < 12) {
				player.body.setVelocity(0, 0);
				autoState = 'idle_base';
				autoNextActionAt = now + autoMoveSeconds * 1000;
				showAutoNavStatus('å¾…å‘½');
			}
			return;
		}
	}

	// ========== å®æ—¶æ¨¡æ‹Ÿæ§åˆ¶åŠŸèƒ½ ==========
	
	// WebSocketè¿æ¥
	let socket = null;
	let isSimulationRunning = false;
	let simulationStep = 0;
	
	// åˆå§‹åŒ–WebSocketè¿æ¥
	function initializeSocket() {
		socket = io();
		
		socket.on('connect', function() {
			console.log('Connected to server');
			updateConnectionStatus(true, 'å·²è¿æ¥åˆ°æœåŠ¡å™¨');
			requestCurrentState();
		});
		
		socket.on('disconnect', function() {
			console.log('Disconnected from server');
			updateConnectionStatus(false, 'ä¸æœåŠ¡å™¨æ–­å¼€è¿æ¥');
		});
		
		socket.on('simulation_update', function(data) {
			console.log('Received simulation update:', data);
			updateSimulationFromServer(data);
		});
		
		socket.on('current_state', function(data) {
			console.log('Received current state:', data);
			updateSimulationFromServer(data);
		});
		
		socket.on('simulation_status', function(data) {
			console.log('Simulation status:', data);
			updateSimulationStatus(data);
		});

		// ç»æµäº‹ä»¶ï¼šå›æ”¾æœåŠ¡é€šè¿‡ SocketIO å¹¿æ’­ 'economy_event'
		socket.on('economy_event', function(evt) {
			try {
				appendEconomyEvent(evt);
				// äº‹ä»¶é€šå¸¸ä¼´éšä»·æ ¼æˆ–åº“å­˜å˜åŒ–ï¼Œåˆ·æ–°ä»·æ ¼æ¿
				loadEconomyState();
			} catch (e) {
				console.error('å¤„ç†ç»æµäº‹ä»¶å¤±è´¥:', e);
			}
		});
	}
	
	// æ›´æ–°è¿æ¥çŠ¶æ€
	function updateConnectionStatus(connected, message) {
		const statusDiv = document.getElementById('connectionStatus');
		const textSpan = document.getElementById('connectionText');
		
		if (statusDiv && textSpan) {
			if (connected) {
				statusDiv.className = 'alert alert-success';
				statusDiv.style.display = 'block';
				textSpan.textContent = message;
				setTimeout(() => {
					statusDiv.style.display = 'none';
				}, 3000);
			} else {
				statusDiv.className = 'alert alert-danger';
				statusDiv.style.display = 'block';
				textSpan.textContent = message;
			}
		}
	}
	
	// è¯·æ±‚å½“å‰çŠ¶æ€
	function requestCurrentState() {
		if (socket) {
			socket.emit('request_current_state');
		}
	}
	
	// ä»æœåŠ¡å™¨æ›´æ–°æ¨¡æ‹Ÿæ•°æ®
	function updateSimulationFromServer(data) {
		console.log('Updating simulation from server:', data);
		
		// å¤„ç†agentsæ•°æ®
		if (data.agents) {
			for (const agentName in data.agents) {
				const agentData = data.agents[agentName];
				
				// æ£€æŸ¥agentæ˜¯å¦å­˜åœ¨äºæ¸¸æˆä¸­
				if (personas[agentName] && agentData.movement) {
					// æ›´æ–°è§’è‰²ä½ç½®
					const persona = personas[agentName];
					const newX = agentData.movement[0] * tile_width;
					const newY = agentData.movement[1] * tile_width;
					
					persona.body.x = newX;
					persona.body.y = newY;
					
					// æ›´æ–°æ¸¸æˆç”»é¢ä¸Šçš„çŠ¶æ€æ˜¾ç¤ºï¼ˆæ˜¾ç¤ºå®Œæ•´å†…å®¹ï¼‰
					if (pronunciatios[agentName]) {
						let displayText = '';
						
						// ä¼˜å…ˆæ˜¾ç¤ºå¯¹è¯å†…å®¹ï¼Œå¦‚æœæ²¡æœ‰å¯¹è¯åˆ™æ˜¾ç¤ºè¡ŒåŠ¨
						if (agentData.recent_chat && agentData.recent_chat.trim() !== '') {
							displayText = agentData.recent_chat;
						} else if (agentData.action) {
							displayText = agentData.action;
						} else if (agentData.currently) {
							displayText = agentData.currently;
						} else {
							displayText = 'æ´»åŠ¨ä¸­';
						}
						
						// é™åˆ¶é•¿åº¦ä»¥é€‚åº”æ¸¸æˆç”»é¢
						if (displayText.length > 25) {
							displayText = displayText.substring(0, 25) + '...';
						}
						
						pronunciatios[agentName].setText(agentName + ': ' + displayText);
						
						// æ›´æ–°å¯¹è¯æ¡†ä½ç½®
						pronunciatios[agentName].x = newX - 15;
						pronunciatios[agentName].y = newY - 15 - 25;
					}
					
					// æ›´æ–°åå­—æ ‡ç­¾ä½ç½®
					if (nameLabels[agentName]) {
						nameLabels[agentName].x = newX;
						nameLabels[agentName].y = newY + 32 + 5;
					}
					
					// æ›´æ–°å³ä¾§è¾¹æ çš„agentçŠ¶æ€
					updateAgentStatus(agentName, agentData.currently || agentData.action || 'æ´»åŠ¨ä¸­');
					
					// å¦‚æœæœ‰æœ€è¿‘çš„å¯¹è¯å†…å®¹ï¼Œæ·»åŠ åˆ°å³ä¾§å¯¹è¯å†å²ï¼ˆå®Œæ•´å†…å®¹ï¼‰
					if (agentData.recent_chat && agentData.recent_chat.trim() !== '') {
						addChatMessage(agentName, agentData.recent_chat);
					}
					
					console.log(`Updated ${agentName} position to (${newX}, ${newY})`);
				} else {
					console.log(`Agent ${agentName} not found in personas or missing movement data`);
				}
			}
		}
		
		// æ›´æ–°æ—¶é—´
		if (data.current_time) {
			const gameTime = new Date(data.current_time);
			if (typeof currentTime !== 'undefined' && currentTime) {
				currentTime.setText(gameTime.toLocaleTimeString("zh-CN", datetime_options));
			}
		}
		
		// æ›´æ–°æ­¥æ•°
		if (data.step !== undefined) {
			simulationStep = data.step;
			const stepCountElement = document.getElementById('stepCount');
			if (stepCountElement) {
				stepCountElement.textContent = simulationStep;
			}
		}
		
		// æ›´æ–°è¿è¡ŒçŠ¶æ€
		if (data.running !== undefined) {
			isSimulationRunning = data.running;
		}
	}
	

	
	// æ›´æ–°agentçŠ¶æ€æ˜¾ç¤º
	function updateAgentStatus(agentName, status) {
		const statusElement = document.getElementById(`status-${agentName}`);
		if (statusElement) {
			statusElement.textContent = status.length > 30 ? status.substring(0, 30) + '...' : status;
		}
	}
	
	// æ·»åŠ å¯¹è¯æ¶ˆæ¯åˆ°å†å²è®°å½•
	let lastMessages = {}; // è®°å½•æ¯ä¸ªagentçš„æœ€åä¸€æ¡æ¶ˆæ¯ï¼Œé¿å…é‡å¤
	
	function addChatMessage(agentName, message) {
		// æ£€æŸ¥æ˜¯å¦æ˜¯é‡å¤æ¶ˆæ¯
		if (lastMessages[agentName] === message) {
			return;
		}
		lastMessages[agentName] = message;
		
		const chatMessages = document.getElementById('chatMessages');
		if (!chatMessages) return;
		
		// åˆ›å»ºæ¶ˆæ¯å…ƒç´ 
		const messageDiv = document.createElement('div');
		messageDiv.className = 'chat-message';
		
		const agentNameDiv = document.createElement('div');
		agentNameDiv.className = 'agent-name';
		agentNameDiv.textContent = agentName;
		
		const messageContentDiv = document.createElement('div');
		messageContentDiv.className = 'message-content';
		messageContentDiv.textContent = message;
		
		const timestampDiv = document.createElement('div');
		timestampDiv.className = 'timestamp';
		const now = new Date();
		timestampDiv.textContent = now.toLocaleTimeString('zh-CN');
		
		messageDiv.appendChild(agentNameDiv);
		messageDiv.appendChild(messageContentDiv);
		messageDiv.appendChild(timestampDiv);
		
		// æ·»åŠ åˆ°èŠå¤©å®¹å™¨
		chatMessages.appendChild(messageDiv);
		
		// é™åˆ¶æ¶ˆæ¯æ•°é‡ï¼Œä¿æŒæœ€æ–°çš„50æ¡
		const messages = chatMessages.querySelectorAll('.chat-message');
		if (messages.length > 50) {
			chatMessages.removeChild(messages[0]);
		}
		
		// è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨
	chatMessages.scrollTop = chatMessages.scrollHeight;
}

// æ·»åŠ å¯¹è¯è®°å½•åˆ°å³ä¾§æ 
function addConversationToSidebar(timeKey, conversationText) {
	const chatMessages = document.getElementById('chatMessages');
	if (!chatMessages) return;
	
	// è§£æå¯¹è¯æ–‡æœ¬ï¼ŒæŒ‰è¡Œåˆ†å‰²
	const lines = conversationText.split('\n').filter(line => line.trim() !== '');
	let currentLocation = '';
	
	for (const line of lines) {
		const trimmedLine = line.trim();
		if (!trimmedLine) continue;
		
		// æ£€æŸ¥æ˜¯å¦æ˜¯åœ°ç‚¹ä¿¡æ¯
		if (trimmedLine.startsWith('åœ°ç‚¹ï¼š')) {
			currentLocation = trimmedLine.substring(3); // ç§»é™¤"åœ°ç‚¹ï¼š"å‰ç¼€
			
			// åˆ›å»ºåœ°ç‚¹ä¿¡æ¯æ°”æ³¡
			const locationDiv = document.createElement('div');
			locationDiv.className = 'chat-message location-message';
			
			const locationNameDiv = document.createElement('div');
			locationNameDiv.className = 'agent-name';
			locationNameDiv.textContent = 'ğŸ“ åœ°ç‚¹';
			
			const locationContentDiv = document.createElement('div');
			locationContentDiv.className = 'message-content';
			locationContentDiv.textContent = currentLocation;
			
			const locationTimestampDiv = document.createElement('div');
			locationTimestampDiv.className = 'timestamp';
			locationTimestampDiv.textContent = timeKey;
			
			locationDiv.appendChild(locationNameDiv);
			locationDiv.appendChild(locationContentDiv);
			locationDiv.appendChild(locationTimestampDiv);
			
			chatMessages.appendChild(locationDiv);
		}
		// æ£€æŸ¥æ˜¯å¦æ˜¯è§’è‰²å¯¹è¯ï¼ˆæ ¼å¼ï¼šè§’è‰²åï¼šå¯¹è¯å†…å®¹ï¼‰
		else if (trimmedLine.includes('ï¼š') && !trimmedLine.startsWith('åœ°ç‚¹ï¼š')) {
			const colonIndex = trimmedLine.indexOf('ï¼š');
			const agentName = trimmedLine.substring(0, colonIndex).trim();
			const message = trimmedLine.substring(colonIndex + 1).trim();
			
			if (agentName && message) {
				// åˆ›å»ºè§’è‰²å¯¹è¯æ°”æ³¡
				const messageDiv = document.createElement('div');
				messageDiv.className = 'chat-message agent-message';
				
				const agentNameDiv = document.createElement('div');
				agentNameDiv.className = 'agent-name';
				agentNameDiv.textContent = agentName;
				
				const messageContentDiv = document.createElement('div');
				messageContentDiv.className = 'message-content';
				messageContentDiv.textContent = message;
				
				const timestampDiv = document.createElement('div');
				timestampDiv.className = 'timestamp';
				timestampDiv.textContent = timeKey;
				
				messageDiv.appendChild(agentNameDiv);
				messageDiv.appendChild(messageContentDiv);
				messageDiv.appendChild(timestampDiv);
				
				chatMessages.appendChild(messageDiv);
			}
		}
	}
	
	// é™åˆ¶æ¶ˆæ¯æ•°é‡ï¼Œä¿æŒæœ€æ–°çš„50æ¡
	const messages = chatMessages.querySelectorAll('.chat-message');
	if (messages.length > 50) {
		for (let i = 0; i < messages.length - 50; i++) {
			chatMessages.removeChild(messages[i]);
		}
	}
	
	// è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨
	chatMessages.scrollTop = chatMessages.scrollHeight;
}

// å›æ”¾æ§åˆ¶å‡½æ•°
	function startReplay() {
		if (socket) {
			socket.emit('start_replay');
			updateReplayButtons('playing');
			console.log('Starting replay...');
		}
	}
	
	function pauseReplay() {
		if (socket) {
			socket.emit('pause_replay');
			updateReplayButtons('paused');
			console.log('Pausing replay...');
		}
	}
	
	function stopReplay() {
		if (socket) {
			socket.emit('stop_replay');
			updateReplayButtons('stopped');
			console.log('Stopping replay...');
		}
	}
	
	// æ›´æ–°å›æ”¾æŒ‰é’®çŠ¶æ€
	function updateReplayButtons(state) {
		const startBtn = document.getElementById('startReplayBtn');
		const pauseBtn = document.getElementById('pauseReplayBtn');
		const stopBtn = document.getElementById('stopReplayBtn');
		
		if (startBtn && pauseBtn && stopBtn) {
			switch(state) {
				case 'playing':
					startBtn.disabled = true;
					pauseBtn.disabled = false;
					stopBtn.disabled = false;
					pauseBtn.innerHTML = '<span class="glyphicon glyphicon-pause"></span> æš‚åœ';
					break;
				case 'paused':
					startBtn.disabled = true;
					pauseBtn.disabled = false;
					stopBtn.disabled = false;
					pauseBtn.innerHTML = '<span class="glyphicon glyphicon-play"></span> ç»§ç»­';
					break;
				case 'stopped':
					startBtn.disabled = false;
					pauseBtn.disabled = true;
					stopBtn.disabled = true;
					pauseBtn.innerHTML = '<span class="glyphicon glyphicon-pause"></span> æš‚åœ';
					break;
			}
		}
	}

	// åœ°å½¢å’Œç¤¾ä¼šå…³ç³»åŠŸèƒ½
	function switchTab(tabName) {
		const terrainBtn = document.getElementById('terrainTabBtn');
		const socialBtn = document.getElementById('socialTabBtn');
		const terrainPanel = document.getElementById('terrainPanel');
		const socialPanel = document.getElementById('socialPanel');
		
		if (tabName === 'terrain') {
			terrainBtn.classList.add('active');
			socialBtn.classList.remove('active');
			terrainBtn.style.background = 'rgba(76, 175, 80, 0.3)';
			socialBtn.style.background = 'rgba(255, 255, 255, 0.1)';
			terrainPanel.style.display = 'block';
			socialPanel.style.display = 'none';
			loadTerrainEvents();
		} else {
			socialBtn.classList.add('active');
			terrainBtn.classList.remove('active');
			socialBtn.style.background = 'rgba(33, 150, 243, 0.3)';
			terrainBtn.style.background = 'rgba(255, 255, 255, 0.1)';
			socialPanel.style.display = 'block';
			terrainPanel.style.display = 'none';
			loadSocialRelationships();
		}
	}
	
function loadTerrainEvents() {
    const container = document.getElementById('terrain-events');
    if (!container) return;
    fetch('/api/terrain/events')
        .then(response => response.json())
        .then(data => {
            container.innerHTML = '';
            
            if (data.events && data.events.length > 0) {
                data.events.forEach(event => {
                    const eventDiv = document.createElement('div');
                    eventDiv.style.cssText = 'background: rgba(76, 175, 80, 0.2); border-left: 3px solid #4CAF50; padding: 10px; margin-bottom: 8px; border-radius: 5px;';
                    
                    // æ ¹æ®äº‹ä»¶ç±»å‹è®¾ç½®ä¸åŒçš„å›¾æ ‡å’Œæè¿°
                    let typeIcon = 'ğŸ—ï¸';
                    let typeText = 'å»ºè®¾æ´»åŠ¨';
                    if (event.type === 'terrain_development') {
                        typeIcon = 'ğŸŒ±';
                        typeText = 'ç¯å¢ƒç¾åŒ–';
                    } else if (event.type === 'social_gathering') {
                        typeIcon = 'ğŸ‘¥';
                        typeText = 'ç¤¾äº¤æ´»åŠ¨';
                    } else if (event.type === 'building_construction') {
                        typeText = 'å»ºç­‘æ–½å·¥';
                    }
                    
                    eventDiv.innerHTML = `
                        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 5px;">
                            <div style="display: flex; align-items: center;">
                                <span style="margin-right: 8px; font-size: 16px;">${typeIcon}</span>
                                <span style="color: #4CAF50; font-weight: 600; font-size: 13px;">${typeText}</span>
                            </div>
                            <span style="color: rgba(255, 255, 255, 0.7); font-size: 11px;">
                                ${new Date(event.timestamp).toLocaleTimeString()}
                            </span>
                        </div>
                        <div style="color: rgba(255, 255, 255, 0.9); font-size: 13px; line-height: 1.4; margin-bottom: 5px;">
                            ${event.description}
                        </div>
                        <div style="color: rgba(255, 255, 255, 0.6); font-size: 12px;">
                            ğŸ‘¤ ${event.agent || event.agents?.join(', ') || 'æœªçŸ¥å‚ä¸è€…'}
                        </div>
                        ${event.social_impact ? `<div style="color: #FFC107; font-size: 12px; margin-top: 5px;">ğŸ’« ${event.social_impact}</div>` : ''}
                    `;
                    
                    container.appendChild(eventDiv);
                });
            } else {
                container.innerHTML = '<div style="color: rgba(255,255,255,0.7); text-align: center; padding: 20px;">æš‚æ— åœ°å½¢äº‹ä»¶è®°å½•</div>';
            }
        })
        .catch(error => {
            console.error('Error loading terrain events:', error);
            if (container) {
                container.innerHTML = '<div style="color: rgba(255,255,255,0.7); text-align: center; padding: 20px;">åŠ è½½åœ°å½¢äº‹ä»¶å¤±è´¥</div>';
            }
        });
}
	
function loadSocialRelationships() {
    const container = document.getElementById('social-relationships');
    if (!container) return;
    fetch('/api/social')
        .then(response => response.json())
        .then(data => {
            container.innerHTML = '';
            
            if (data.relationships && data.relationships.length > 0) {
                data.relationships.forEach(rel => {
						const relDiv = document.createElement('div');
						relDiv.style.cssText = 'background: rgba(33, 150, 243, 0.2); border-left: 3px solid #2196F3; padding: 10px; margin-bottom: 8px; border-radius: 5px;';
						
						// æ ¹æ®å…³ç³»ç±»å‹è®¾ç½®å›¾æ ‡å’Œé¢œè‰²
						let typeIcon = 'ğŸ‘¥';
						let typeColor = '#2196F3';
						if (rel.type === 'friend' || rel.type === 'FRIEND') {
							typeIcon = 'ğŸ‘«';
							typeColor = '#4CAF50';
						} else if (rel.type === 'romantic_interest' || rel.type === 'ROMANTIC') {
							typeIcon = 'ğŸ’•';
							typeColor = '#E91E63';
						} else if (rel.type === 'colleague' || rel.type === 'COLLEAGUE') {
							typeIcon = 'ğŸ¤';
							typeColor = '#FF9800';
						} else if (rel.type === 'rival' || rel.type === 'RIVAL') {
							typeIcon = 'âš”ï¸';
							typeColor = '#F44336';
						} else if (rel.type === 'acquaintance' || rel.type === 'ACQUAINTANCE') {
							typeIcon = 'ğŸ¤';
							typeColor = '#9E9E9E';
						}
						
						const intimacyValue = rel.intimacy || rel.strength || 0;
						const intimacyColor = intimacyValue > 70 ? '#4CAF50' : 
											 intimacyValue > 40 ? '#FFC107' : '#FF5722';
						
						relDiv.innerHTML = `
							<div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
								<div style="display: flex; align-items: center;">
									<span style="margin-right: 8px; font-size: 16px;">${typeIcon}</span>
									<span style="color: ${typeColor}; font-weight: 600; font-size: 13px;">
										${rel.agent1} â†” ${rel.agent2}
									</span>
								</div>
								<span style="color: ${intimacyColor}; font-size: 12px; font-weight: 600;">
									${Math.round(intimacyValue)}%
								</span>
							</div>
							<div style="color: rgba(255, 255, 255, 0.8); font-size: 12px; margin-bottom: 5px;">
								å…³ç³»ç±»å‹: ${getRelationshipTypeName(rel.type)} | çŠ¶æ€: ${getStatusName(rel.status)}
							</div>
							${rel.interaction_count ? `
								<div style="color: rgba(255, 255, 255, 0.6); font-size: 11px; margin-bottom: 3px;">
									ğŸ’¬ äº’åŠ¨æ¬¡æ•°: ${rel.interaction_count}
									${rel.positive_interactions ? ` | ğŸ‘ ${rel.positive_interactions}` : ''}
									${rel.negative_interactions ? ` | ğŸ‘ ${rel.negative_interactions}` : ''}
								</div>
							` : ''}
							${rel.last_interaction ? `
								<div style="color: rgba(255, 255, 255, 0.5); font-size: 10px;">
									ğŸ•’ æœ€åäº’åŠ¨: ${new Date(rel.last_interaction).toLocaleTimeString()}
								</div>
							` : ''}
						`;
						
						container.appendChild(relDiv);
					});
				} else {
					container.innerHTML = '<div style="color: rgba(255,255,255,0.7); text-align: center; padding: 20px;">æš‚æ— ç¤¾ä¼šå…³ç³»æ•°æ®</div>';
				}
        })
        .catch(error => {
            console.error('Error loading social relationships:', error);
            if (container) {
                container.innerHTML = '<div style="color: rgba(255,255,255,0.7); text-align: center; padding: 20px;">åŠ è½½ç¤¾ä¼šå…³ç³»å¤±è´¥</div>';
            }
        });
}
	
	function getRelationshipTypeName(type) {
		const typeNames = {
			'stranger': 'é™Œç”Ÿäºº',
			'acquaintance': 'ç†Ÿäºº',
			'friend': 'æœ‹å‹',
			'close_friend': 'å¯†å‹',
			'colleague': 'åŒäº‹',
			'neighbor': 'é‚»å±…',
			'romantic_interest': 'æš—æ‹å¯¹è±¡',
			'dating': 'çº¦ä¼šä¸­',
			'boyfriend_girlfriend': 'æ‹äºº',
			'engaged': 'è®¢å©š',
			'married': 'å·²å©š',
			'ex_partner': 'å‰ä»»',
			'enemy': 'æ•Œäºº',
			'family': 'å®¶äºº'
		};
		return typeNames[type] || type;
	}
	
	function getStatusName(status) {
		const statusNames = {
			'developing': 'å‘å±•ä¸­',
			'stable': 'ç¨³å®š',
			'declining': 'è¡°é€€ä¸­',
			'conflicted': 'å†²çªä¸­',
			'ended': 'å·²ç»“æŸ'
		};
		return statusNames[status] || status;
	}

	// å¤©æ°”å’Œæ—¶é—´æ˜¾ç¤ºå‡½æ•°ï¼ˆè‡ªåŠ¨æ›´æ–°ï¼‰
	
	// å¤©æ°”è§†è§‰æ•ˆæœæ§åˆ¶å‡½æ•° - æ”¯æŒå¹³æ»‘è¿‡æ¸¡
	let currentWeatherType = null;
	
	function updateWeatherVisualEffects(weatherType) {
		// å¦‚æœå¤©æ°”ç±»å‹æ²¡æœ‰å˜åŒ–ï¼Œä¸éœ€è¦æ›´æ–°
		if (currentWeatherType === weatherType) {
			return;
		}
		
		const rainEffect = document.getElementById('rainEffect');
		const snowEffect = document.getElementById('snowEffect');
		const fogEffect = document.getElementById('fogEffect');
		const cloudyEffect = document.getElementById('cloudyEffect');
		const stormEffect = document.getElementById('stormEffect');
		
		// å…ˆæ·¡å‡ºå½“å‰æ•ˆæœ
		fadeOutCurrentWeatherEffects();
		
		// å»¶è¿Ÿåæ·¡å…¥æ–°æ•ˆæœ
		setTimeout(() => {
			fadeInNewWeatherEffect(weatherType);
			currentWeatherType = weatherType;
		}, 1000); // 1ç§’å»¶è¿Ÿï¼Œè®©æ·¡å‡ºæ•ˆæœå®Œæˆ
	}
	
	// æ·¡å‡ºå½“å‰å¤©æ°”æ•ˆæœ
	function fadeOutCurrentWeatherEffects() {
		const effects = ['rainEffect', 'snowEffect', 'fogEffect', 'cloudyEffect', 'stormEffect'];
		
		effects.forEach(effectId => {
			const element = document.getElementById(effectId);
			if (element && element.classList.contains('active')) {
				element.classList.add('fade-out');
				element.classList.remove('active', 'fade-in');
				
				// åœ¨åŠ¨ç”»å®Œæˆåç§»é™¤fade-outç±»
				setTimeout(() => {
					element.classList.remove('fade-out');
				}, 3000);
			}
		});
	}
	
	// æ·¡å…¥æ–°å¤©æ°”æ•ˆæœ
	function fadeInNewWeatherEffect(weatherType) {
		const rainEffect = document.getElementById('rainEffect');
		const snowEffect = document.getElementById('snowEffect');
		const fogEffect = document.getElementById('fogEffect');
		const cloudyEffect = document.getElementById('cloudyEffect');
		const stormEffect = document.getElementById('stormEffect');
		
		// æ ¹æ®å¤©æ°”ç±»å‹æ¿€æ´»ç›¸åº”æ•ˆæœ
		switch(weatherType) {
			case 'rainy':
				rainEffect.classList.add('fade-in', 'active');
				rainEffect.classList.remove('fade-out');
				break;
			case 'stormy':
				stormEffect.classList.add('fade-in', 'active');
				stormEffect.classList.remove('fade-out');
				break;
			case 'snowy':
				snowEffect.classList.add('fade-in', 'active');
				snowEffect.classList.remove('fade-out');
				break;
			case 'foggy':
				fogEffect.classList.add('active');
				fogEffect.classList.remove('fade-out');
				break;
			case 'cloudy':
				cloudyEffect.classList.add('active');
				cloudyEffect.classList.remove('fade-out');
				break;
			case 'sunny':
			default:
				// æ™´å¤©æˆ–å…¶ä»–å¤©æ°”ç±»å‹ä¸æ˜¾ç¤ºç‰¹æ®Šæ•ˆæœ
				break;
		}
		
		// æ¸…ç†fade-inç±»
		setTimeout(() => {
			const effects = [rainEffect, snowEffect, fogEffect, cloudyEffect, stormEffect];
			effects.forEach(effect => {
				if (effect) {
					effect.classList.remove('fade-in');
				}
			});
		}, 4000);
	}
	
	// æ˜¼å¤œè§†è§‰æ•ˆæœæ§åˆ¶å‡½æ•° - åŸºäºå…‰ç…§å¼ºåº¦çš„åŠ¨æ€è¿‡æ¸¡
	function updateDayNightVisualEffects(timeOfDay, lightIntensity = null) {
		const dayNightOverlay = document.getElementById('dayNightOverlay');
		
		// ç§»é™¤æ‰€æœ‰æ—¶é—´æ®µç±»
		dayNightOverlay.classList.remove('dawn', 'morning', 'noon', 'afternoon', 'dusk', 'evening', 'night', 'midnight');
		
		// å¦‚æœæœ‰å…‰ç…§å¼ºåº¦æ•°æ®ï¼Œä½¿ç”¨åŠ¨æ€è¿‡æ¸¡
		if (lightIntensity !== null) {
			updateDynamicLighting(dayNightOverlay, timeOfDay, lightIntensity);
		} else {
			// å›é€€åˆ°åŸºäºæ—¶é—´æ®µçš„é™æ€åˆ‡æ¢
			updateStaticTimeOfDay(dayNightOverlay, timeOfDay);
		}
	}
	
	// åŠ¨æ€å…‰ç…§è¿‡æ¸¡å‡½æ•°
	function updateDynamicLighting(overlay, timeOfDay, lightIntensity) {
		// æ ¹æ®å…‰ç…§å¼ºåº¦å’Œæ—¶é—´æ®µè®¡ç®—åŠ¨æ€èƒŒæ™¯
		const intensity = Math.max(0, Math.min(1, lightIntensity));
		
		// å®šä¹‰ä¸åŒæ—¶é—´æ®µçš„åŸºç¡€é¢œè‰²
		const timeColors = {
			'midnight': { r: 15, g: 15, b: 60, alpha: 0.7 },
			'night': { r: 25, g: 25, b: 112, alpha: 0.6 },
			'dawn': { r: 255, g: 182, b: 193, alpha: 0.4 },
			'morning': { r: 255, g: 248, b: 220, alpha: 0.1 },
			'noon': { r: 255, g: 255, b: 255, alpha: 0.0 },
			'afternoon': { r: 255, g: 235, b: 205, alpha: 0.1 },
			'dusk': { r: 255, g: 94, b: 77, alpha: 0.5 },
			'evening': { r: 255, g: 94, b: 77, alpha: 0.5 }
		};
		
		const baseColor = timeColors[timeOfDay] || timeColors['noon'];
		
		// æ ¹æ®å…‰ç…§å¼ºåº¦è°ƒæ•´é€æ˜åº¦
		let adjustedAlpha = baseColor.alpha;
		if (timeOfDay === 'night' || timeOfDay === 'midnight') {
			// å¤œæ™šï¼šå…‰ç…§å¼ºåº¦è¶Šä½ï¼Œè¦†ç›–å±‚è¶Šæš—
			adjustedAlpha = baseColor.alpha * (1 - intensity * 0.3);
		} else if (timeOfDay === 'dawn' || timeOfDay === 'dusk' || timeOfDay === 'evening') {
			// é»„æ˜/é»æ˜ï¼šä¿æŒåŸºç¡€é€æ˜åº¦ï¼Œè½»å¾®è°ƒæ•´
			adjustedAlpha = baseColor.alpha * (0.8 + intensity * 0.4);
		} else {
			// ç™½å¤©ï¼šå…‰ç…§å¼ºåº¦è¶Šé«˜ï¼Œè¦†ç›–å±‚è¶Šé€æ˜
			adjustedAlpha = baseColor.alpha * (1 - intensity * 0.8);
		}
		
		// åº”ç”¨åŠ¨æ€èƒŒæ™¯è‰²
		if (timeOfDay === 'dawn' || timeOfDay === 'dusk' || timeOfDay === 'evening') {
			// æ¸å˜æ•ˆæœçš„æ—¶é—´æ®µ
			overlay.style.background = `linear-gradient(to bottom, 
				rgba(${baseColor.r}, ${baseColor.g}, ${baseColor.b}, ${adjustedAlpha}) 0%, 
				rgba(${Math.floor(baseColor.r * 0.8)}, ${Math.floor(baseColor.g * 0.6)}, ${Math.floor(baseColor.b * 0.4)}, ${adjustedAlpha * 0.7}) 50%, 
				rgba(${Math.floor(baseColor.r * 0.6)}, ${Math.floor(baseColor.g * 0.4)}, ${Math.floor(baseColor.b * 0.2)}, ${adjustedAlpha * 0.4}) 100%)`;
		} else {
			// çº¯è‰²æ•ˆæœçš„æ—¶é—´æ®µ
			overlay.style.background = `rgba(${baseColor.r}, ${baseColor.g}, ${baseColor.b}, ${adjustedAlpha})`;
		}
	}
	
	// é™æ€æ—¶é—´æ®µåˆ‡æ¢å‡½æ•°ï¼ˆå›é€€æ–¹æ¡ˆï¼‰
	function updateStaticTimeOfDay(overlay, timeOfDay) {
		switch(timeOfDay) {
			case 'dawn':
				overlay.classList.add('dawn');
				break;
			case 'morning':
				overlay.classList.add('morning');
				break;
			case 'noon':
				overlay.classList.add('noon');
				break;
			case 'afternoon':
				overlay.classList.add('afternoon');
				break;
			case 'dusk':
				overlay.classList.add('dusk');
				break;
			case 'evening':
				overlay.classList.add('evening');
				break;
			case 'night':
				overlay.classList.add('night');
				break;
			case 'midnight':
				overlay.classList.add('midnight');
				break;
			default:
				overlay.classList.add('morning');
				break;
		}
	}
	
	function updateWeatherDisplay() {
		fetch('/api/weather')
		.then(response => response.json())
		.then(data => {
			if (data.status === 'success') {
				const weather = data.weather;
				const weatherEmojis = {
					'sunny': 'â˜€ï¸',
					'cloudy': 'â˜ï¸',
					'rainy': 'ğŸŒ§ï¸',
					'stormy': 'â›ˆï¸',
					'snowy': 'â„ï¸',
					'foggy': 'ğŸŒ«ï¸'
				};
				
				const weatherNames = {
					'sunny': 'æ™´å¤©',
					'cloudy': 'å¤šäº‘',
					'rainy': 'é›¨å¤©',
					'stormy': 'æš´é£é›¨',
					'snowy': 'é›ªå¤©',
					'foggy': 'é›¾å¤©'
				};
				
				const emoji = weatherEmojis[weather.type] || 'ğŸŒ¤ï¸';
				const name = weatherNames[weather.type] || weather.type;
				
				// æ›´æ–°å³ä¾§é¢æ¿
				document.getElementById('current-weather').textContent = `${emoji} ${name}`;
				document.getElementById('weather-details').textContent = 
					`æ¸©åº¦: ${weather.temperature}Â°C | æ¹¿åº¦: ${weather.humidity}%`;
				
				// æ›´æ–°æ¸¸æˆåŒºåŸŸæµ®åŠ¨é¢æ¿
				const gameWeatherElement = document.getElementById('current-weather-game');
				const gameWeatherDetailsElement = document.getElementById('weather-details-game');
				if (gameWeatherElement) {
					gameWeatherElement.textContent = `${emoji} ${name}`;
				}
				if (gameWeatherDetailsElement) {
					gameWeatherDetailsElement.textContent = `æ¸©åº¦: ${weather.temperature}Â°C`;
				}
				
				// æ›´æ–°è§†è§‰æ•ˆæœ
				updateWeatherVisualEffects(weather.type);
			}
		})
		.catch(error => {
			console.error('è·å–å¤©æ°”æ•°æ®æ—¶å‡ºé”™:', error);
		});
	}
	
	function updateTimeDisplay() {
		fetch('/api/time')
		.then(response => response.json())
		.then(data => {
			if (data.status === 'success') {
				const time = data.time;
				const timeEmojis = {
					'dawn': 'ğŸŒ…',
					'morning': 'ğŸŒ…',
					'noon': 'â˜€ï¸',
					'afternoon': 'ğŸŒ‡',
					'evening': 'ğŸŒ†',
					'night': 'ğŸŒ™',
					'midnight': 'ğŸŒ™'
				};
				
				const timeNames = {
					'dawn': 'é»æ˜',
					'morning': 'ä¸Šåˆ',
					'noon': 'ä¸­åˆ',
					'afternoon': 'ä¸‹åˆ',
					'evening': 'å‚æ™š',
					'night': 'å¤œæ™š',
					'midnight': 'åˆå¤œ'
				};
				
				const emoji = timeEmojis[time.time_of_day] || 'ğŸŒ¤ï¸';
				const name = timeNames[time.time_of_day] || time.time_of_day;
				
				// æ›´æ–°å³ä¾§é¢æ¿
				document.getElementById('current-time').textContent = `${emoji} ${name}`;
				
				const lightPercent = Math.round(time.light_intensity * 100);
				const activityPercent = Math.round(time.activity_modifier * 100);
				document.getElementById('time-details').textContent = 
					`å…‰ç…§: ${lightPercent}% | æ´»åŠ¨: ${activityPercent}%`;
				
				// æ›´æ–°æ¸¸æˆåŒºåŸŸæµ®åŠ¨é¢æ¿
				const gameTimeElement = document.getElementById('current-time-game');
				const gameTimeDetailsElement = document.getElementById('time-details-game');
				if (gameTimeElement) {
					gameTimeElement.textContent = `${emoji} ${name}`;
				}
				if (gameTimeDetailsElement) {
					gameTimeDetailsElement.textContent = `å…‰ç…§: ${lightPercent}%`;
				}
				
				// æ›´æ–°æ˜¼å¤œè§†è§‰æ•ˆæœï¼Œä¼ é€’å…‰ç…§å¼ºåº¦å®ç°åŠ¨æ€è¿‡æ¸¡
				updateDayNightVisualEffects(time.time_of_day, time.light_intensity);
			}
		})
		.catch(error => {
			console.error('è·å–æ—¶é—´æ•°æ®æ—¶å‡ºé”™:', error);
		});
	}

	// æ–‡æ˜æ¼”åŒ–çŠ¶æ€æ˜¾ç¤º
	function updateCivilizationDisplay() {
		fetch('/api/civilization/state')
			.then(response => response.json())
			.then(data => {
				if (data.status === 'success' && data.state) {
					const s = data.state;
					const eraEl = document.getElementById('civilization-era');
					const progEl = document.getElementById('civilization-progress-bar');
					const popEl = document.getElementById('civilization-population');
					const techEl = document.getElementById('civilization-tech');
					const econEl = document.getElementById('civilization-economy');
					const infraEl = document.getElementById('civilization-infrastructure');
					const sidebarEconEl = document.getElementById('sidebar-economy-index');
					const sidebarInfraEl = document.getElementById('sidebar-infrastructure-level');
					const cultEl = document.getElementById('civilization-culture');
					const stabEl = document.getElementById('civilization-stability');
					const govEl = document.getElementById('civilization-governance');
					const autoEl = document.getElementById('civilization-autopilot-status');

					if (eraEl) {
						eraEl.textContent = `${s.era_emoji} ${s.era_name}`;
					}
					if (progEl) {
						progEl.style.width = `${Math.round(s.progress_to_next_era)}%`;
					}
					if (popEl) popEl.textContent = s.population.toLocaleString();
					if (techEl) techEl.textContent = s.tech_index;
					if (econEl) econEl.textContent = s.economy_index;
					if (infraEl) infraEl.textContent = s.infrastructure_level;
					if (sidebarEconEl) sidebarEconEl.textContent = Math.round(Number(s.economy_index));
					if (sidebarInfraEl) sidebarInfraEl.textContent = Math.round(Number(s.infrastructure_level));
					if (cultEl) cultEl.textContent = s.culture_index;
					if (stabEl) stabEl.textContent = `${Math.round(s.stability)}%`;
					if (govEl) govEl.textContent = s.governance;
					if (autoEl) autoEl.textContent = s.auto_actions_enabled ? 'å¼€å¯' : 'å…³é—­';
					// å°†ç»æµæŒ‡æ•°ä¸åŸºå»ºç­‰çº§åŒæ­¥åˆ°å³ä¾§å¯¹è¯è®°å½•
					showEconomyInfraStatus(s);
				}
			})
			.catch(err => {
				console.error('è·å–æ–‡æ˜çŠ¶æ€å¤±è´¥:', err);
			});
	}

	// åœ¨å³ä¾§å¯¹è¯è®°å½•é¡¶éƒ¨ä¿¡æ¯æ¡æ˜¾ç¤ºç»æµæŒ‡æ•°ä¸åŸºå»ºç­‰çº§
	function showEconomyInfraStatus(state) {
		try {
			const econ = state?.economy_index;
			const infra = state?.infrastructure_level;
			if (econ == null || infra == null) return;
			const econRound = Math.round(Number(econ));
			const infraRound = Math.round(Number(infra));
			const barEcon = document.getElementById('sidebar-economy-index');
			const barInfra = document.getElementById('sidebar-infrastructure-level');
			if (barEcon) barEcon.textContent = econRound;
			if (barInfra) barInfra.textContent = infraRound;
		} catch (_) {}
	}

	function loadCivilizationEvents() {
		fetch('/api/civilization/events?limit=8')
			.then(response => response.json())
			.then(data => {
				const container = document.getElementById('civilization-events');
				if (!container) return;
				container.innerHTML = '';
				const events = data.events || [];
				if (events.length === 0) {
					container.innerHTML = '<div style="color: rgba(255,255,255,0.7); text-align: center; padding: 12px;">æš‚æ— æ–‡æ˜äº‹ä»¶</div>';
					return;
				}

				events.forEach(ev => {
					const item = document.createElement('div');
					item.style.cssText = 'background: rgba(255, 255, 255, 0.08); border-left: 3px solid #FFC107; padding: 10px; margin-bottom: 8px; border-radius: 6px;';
					const t = new Date(ev.timestamp);
					const timeStr = isNaN(t.getTime()) ? ev.timestamp : t.toLocaleTimeString();
					item.innerHTML = `
						<div style="display:flex; align-items:center; justify-content: space-between; margin-bottom: 6px;">
							<div style="display:flex; align-items:center;">
								<span style="margin-right:8px;">ğŸ›ï¸</span>
								<span style="color:#FFC107; font-weight:600; font-size:13px;">${ev.title || 'æ–‡æ˜äº‹ä»¶'}</span>
							</div>
							<span style="color: rgba(255,255,255,0.6); font-size: 11px;">${timeStr}</span>
						</div>
						<div style="color: rgba(255,255,255,0.9); font-size: 12px; line-height: 1.5;">${ev.description || ''}</div>
					`;
					container.appendChild(item);
				});
			})
			.catch(err => {
				console.error('åŠ è½½æ–‡æ˜äº‹ä»¶å¤±è´¥:', err);
				const container = document.getElementById('civilization-events');
				if (container) container.innerHTML = '<div style="color: rgba(255,255,255,0.7); text-align: center; padding: 12px;">åŠ è½½å¤±è´¥</div>';
			});
	}

	function sendCivilizationCommand(action, intensity = 1, metadata = {}) {
		try {
			fetch('/api/civilization/command', {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({ action, intensity, metadata })
			})
				.then(res => res.json())
				.then(data => {
					if (data.status === 'success') {
						updateCivilizationDisplay();
						loadCivilizationEvents();
					} else {
						console.error('æ–‡æ˜æŒ‡ä»¤è¿”å›é”™è¯¯:', data);
					}
				})
				.catch(err => {
					console.error('å‘é€æ–‡æ˜æŒ‡ä»¤å¤±è´¥:', err);
				});
		} catch (e) {
			console.error('å‘é€æ–‡æ˜æŒ‡ä»¤å¼‚å¸¸:', e);
		}
	}

	// ================= ç»æµé¢æ¿ä¸äº‹ä»¶ =================

	function formatPriceKey(key) {
		const map = {
			'res:WOOD': 'ğŸªµ æœ¨æ',
			'res:STONE': 'ğŸª¨ çŸ³å¤´',
			'res:METAL': 'â›“ï¸ é‡‘å±',
			'res:FOOD': 'ğŸ¥« é£Ÿç‰©',
			'res:WATER': 'ğŸ’§ æ°´',
			'res:ENERGY': 'âš¡ èƒ½æº',
			'res:LABOR': 'ğŸ§‘â€ğŸ­ åŠ³åŠ¨åŠ›',
			'item:food_pack': 'ğŸ’ é£Ÿç‰©åŒ…',
			'item:material_brick': 'ğŸ§± ç –å—',
			'item:tool_axe': 'ğŸª“ æ–§å¤´',
			'item:tool_pickaxe': 'â›ï¸ é•',
			'item:tool_hammer': 'ğŸ”¨ é”¤å­',
		};
		return map[key] || map[key.toLowerCase()] || key;
	}

	function renderEconomyPrices(prices) {
		const container = document.getElementById('economy-price-list');
		if (!container) return;
		const order = [
			'res:WOOD', 'res:STONE', 'res:METAL', 'res:FOOD', 'res:WATER', 'res:ENERGY', 'res:LABOR',
			'item:food_pack', 'item:material_brick', 'item:tool_axe', 'item:tool_pickaxe', 'item:tool_hammer'
		];
		let keys = order.filter(k => prices && (k in prices));
		// è¿½åŠ ä»»ä½•æœªåœ¨orderä¸­çš„å…¶ä»–ä»·æ ¼é”®
		if (prices) {
			Object.keys(prices).forEach(k => { if (!keys.includes(k)) keys.push(k); });
		}
		container.innerHTML = '';
		if (!keys.length) {
			container.innerHTML = '<div style="color: rgba(255,255,255,0.7); grid-column: 1 / -1; text-align: center; padding: 10px;">æš‚æ— ä»·æ ¼æ•°æ®</div>';
			return;
		}
		keys.forEach(k => {
			const val = Number(prices[k]).toFixed(2);
			const card = document.createElement('div');
			card.style.cssText = 'background: rgba(255,255,255,0.08); border-left: 3px solid #4CAF50; padding: 8px; border-radius: 6px; display: flex; align-items: center; justify-content: space-between;';
			card.innerHTML = `
				<span style="color: #4CAF50; font-weight: 600; font-size: 13px;">${formatPriceKey(k)}</span>
				<span style="color: rgba(255,255,255,0.9); font-size: 13px;">â‚µ ${val}</span>
			`;
			container.appendChild(card);
		});
	}

	function appendEconomyEvent(evt) {
		const container = document.getElementById('economy-events');
		if (!container) return;
		const item = document.createElement('div');
		item.style.cssText = 'background: rgba(255,255,255,0.08); border-left: 3px solid #2196F3; padding: 10px; margin-bottom: 8px; border-radius: 6px;';
		const t = new Date(evt.timestamp);
		const timeStr = isNaN(t.getTime()) ? (evt.timestamp || '') : t.toLocaleTimeString();
		let title = 'ç»æµäº‹ä»¶';
		let icon = 'ğŸ’±';
		let desc = '';
		if (evt.type === 'trade') {
			icon = 'ğŸ¤';
			title = 'äº¤æ˜“è¾¾æˆ';
			desc = `${evt.sender} â†” ${evt.receiver}`;
			const money = [];
			if (evt.offer_money && Number(evt.offer_money) > 0) money.push(`å‡ºä»· â‚µ${Number(evt.offer_money).toFixed(2)}`);
			if (evt.request_money && Number(evt.request_money) > 0) money.push(`ç´¢ä»· â‚µ${Number(evt.request_money).toFixed(2)}`);
			const resSummary = [];
			if (evt.offer_resources) resSummary.push(`è®©å‡º: ${Object.entries(evt.offer_resources).map(([k,v])=>`${k}Ã—${v}`).join(', ')}`);
			if (evt.request_resources) resSummary.push(`è·å¾—: ${Object.entries(evt.request_resources).map(([k,v])=>`${k}Ã—${v}`).join(', ')}`);
			if (evt.offer_items) resSummary.push(`è®©å‡ºç‰©å“: ${Object.entries(evt.offer_items).map(([k,v])=>`${k}Ã—${v}`).join(', ')}`);
			if (evt.request_items) resSummary.push(`è·å¾—ç‰©å“: ${Object.entries(evt.request_items).map(([k,v])=>`${k}Ã—${v}`).join(', ')}`);
			desc = `${desc}${money.length?(' | '+money.join(' / ')):''}${resSummary.length?(' | '+resSummary.join(' / ')):''}`;
		} else if (evt.type === 'craft') {
			icon = 'ğŸ› ï¸';
			title = 'åˆæˆå®Œæˆ';
			desc = `${evt.agent} äº§å‡º ${evt.output?.item || ''} Ã— ${evt.output?.count || 1}`;
		}
		item.innerHTML = `
			<div style="display:flex; align-items:center; justify-content: space-between; margin-bottom: 6px;">
				<div style="display:flex; align-items:center;"><span style="margin-right:8px;">${icon}</span><span style="color:#2196F3; font-weight:600; font-size:13px;">${title}</span></div>
				<span style="color: rgba(255,255,255,0.6); font-size: 11px;">${timeStr}</span>
			</div>
			<div style="color: rgba(255,255,255,0.9); font-size: 12px; line-height: 1.5;">${desc}</div>
		`;
		container.appendChild(item);
		// é™åˆ¶äº‹ä»¶æ¡ç›®æ•°é‡
		const items = container.children;
		if (items.length > 50) {
			container.removeChild(items[0]);
		}
		container.scrollTop = container.scrollHeight;
	}

	function loadEconomyState() {
		fetch('/api/economy/state')
			.then(res => res.json())
			.then(data => {
				if (data && data.prices) {
					renderEconomyPrices(data.prices);
				}
			})
			.catch(err => console.error('åŠ è½½ç»æµçŠ¶æ€å¤±è´¥:', err));
	}

	function loadEconomyEvents() {
		fetch('/api/economy/events')
			.then(res => res.json())
			.then(data => {
				const container = document.getElementById('economy-events');
				if (!container) return;
				container.innerHTML = '';
				const events = data?.events || data || [];
				if (Array.isArray(events)) {
					events.forEach(ev => appendEconomyEvent(ev));
				} else {
					container.innerHTML = '<div style="color: rgba(255,255,255,0.7); text-align: center; padding: 10px;">æš‚æ— ç»æµäº‹ä»¶</div>';
				}
			})
			.catch(err => console.error('åŠ è½½ç»æµäº‹ä»¶å¤±è´¥:', err));
	}

	// é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
	document.addEventListener('DOMContentLoaded', function() {
		// åˆå§‹åŒ–WebSocketè¿æ¥
		initializeSocket();
		
		// åˆå§‹åŒ–å›æ”¾æŒ‰é’®çŠ¶æ€
		updateReplayButtons('stopped');
		
		// åˆå§‹åŒ–åœ°å½¢äº‹ä»¶æ˜¾ç¤º
		loadTerrainEvents();
		
		// åˆå§‹åŒ–å¤©æ°”å’Œæ—¶é—´æ˜¾ç¤º
		updateWeatherDisplay();
		updateTimeDisplay();
		updateCivilizationDisplay();
		loadCivilizationEvents();

		// åˆå§‹åŒ–ç»æµé¢æ¿ä¸äº‹ä»¶
		loadEconomyState();
		loadEconomyEvents();
		const refreshBtn = document.getElementById('refreshEconomyBtn');
		if (refreshBtn) {
			refreshBtn.addEventListener('click', () => {
				loadEconomyState();
				loadEconomyEvents();
			});
		}

		// æ–‡æ˜æŒ‡ä»¤æŒ‰é’®å’Œè¾“å…¥ç»‘å®š
		const cmdInput = document.getElementById('civilization-cmd-input');
		const cmdSubmit = document.getElementById('civilization-cmd-submit');
		if (cmdSubmit) {
			cmdSubmit.addEventListener('click', () => {
				const val = (cmdInput && cmdInput.value || '').trim();
				if (!val) {
					// é»˜è®¤å½“ä½œå®£ä¼ 
					sendCivilizationCommand('å®£ä¼ ');
					return;
				}
				sendCivilizationCommand(val);
				cmdInput.value = '';
			});
		}
		const btnBuild = document.getElementById('btn-civ-build');
		const btnResearch = document.getElementById('btn-civ-research');
		const btnStabilize = document.getElementById('btn-civ-stabilize');
		const btnPolicy = document.getElementById('btn-civ-policy');
		if (btnBuild) btnBuild.addEventListener('click', () => sendCivilizationCommand('å»ºè®¾'));
		if (btnResearch) btnResearch.addEventListener('click', () => sendCivilizationCommand('ç§‘ç ”'));
		if (btnStabilize) btnStabilize.addEventListener('click', () => sendCivilizationCommand('ç¨³å®š'));
		if (btnPolicy) btnPolicy.addEventListener('click', () => sendCivilizationCommand('æ”¿ç­–'));
		
		// å®šæœŸæ›´æ–°åœ°å½¢å’Œç¤¾ä¼šå…³ç³»æ•°æ®
		setInterval(() => {
			const terrainPanel = document.getElementById('terrainPanel');
			const socialPanel = document.getElementById('socialPanel');
			
			if (terrainPanel && terrainPanel.style.display !== 'none') {
				loadTerrainEvents();
			}
			if (socialPanel && socialPanel.style.display !== 'none') {
				loadSocialRelationships();
			}
		}, 10000); // æ¯10ç§’æ›´æ–°ä¸€æ¬¡
		
		// å®šæœŸæ›´æ–°å¤©æ°”å’Œæ—¶é—´æ˜¾ç¤ºï¼ˆè‡ªåŠ¨å˜åŒ–ç³»ç»Ÿï¼‰
		setInterval(() => {
			updateWeatherDisplay();
			updateTimeDisplay();
			updateOnlineResidentsCount();
		}, 2000); // æ¯2ç§’æ›´æ–°ä¸€æ¬¡ï¼Œç¡®ä¿è‡ªåŠ¨å˜åŒ–åŠæ—¶æ˜¾ç¤º

		// å®šæœŸæ›´æ–°æ–‡æ˜çŠ¶æ€ä¸äº‹ä»¶
		setInterval(() => {
			updateCivilizationDisplay();
			loadCivilizationEvents();
		}, 4000);

		// å®šæœŸåˆ·æ–°ç»æµä»·æ ¼ï¼ˆäº‹ä»¶é€šè¿‡Socketå®æ—¶è¿½åŠ ï¼‰
		setInterval(() => {
			loadEconomyState();
		}, 5000);

		// åˆå§‹åŒ–ç›´æ’­è‡ªåŠ¨å·¡èˆªæ§åˆ¶
		setupAutoNavControls();
		
		// å¯¹è¯æ§åˆ¶åŠŸèƒ½
		setupChatControls();

	});
	
	// æ›´æ–°åœ¨çº¿å±…æ°‘æ•°é‡
	function updateOnlineResidentsCount() {
		// è¿™é‡Œå¯ä»¥ä»APIè·å–å®é™…çš„åœ¨çº¿å±…æ°‘æ•°é‡
		// æš‚æ—¶ä½¿ç”¨éšæœºæ•°æ¨¡æ‹Ÿ
		const count = Math.floor(Math.random() * 5) + 6; // 6-10äºº
		const countElement = document.getElementById('online-residents-count');
		if (countElement) {
			countElement.textContent = `${count} äºº`;
		}
	}
	
	// è®¾ç½®å¯¹è¯æ§åˆ¶æŒ‰é’®åŠŸèƒ½
	function setupChatControls() {
		const startBtn = document.getElementById('chat-start-btn');
		const replayBtn = document.getElementById('chat-replay-btn');
		const pauseBtn = document.getElementById('chat-pause-btn');
		const stopBtn = document.getElementById('chat-stop-btn');
		const clearBtn = document.getElementById('chat-clear-btn');
		
		if (startBtn) {
			startBtn.addEventListener('click', () => {
				console.log('å¼€å§‹å¯¹è¯');
				// è¿™é‡Œå¯ä»¥æ·»åŠ å¼€å§‹å¯¹è¯çš„é€»è¾‘
				showChatMessage('ç³»ç»Ÿ', 'å¯¹è¯å·²å¼€å§‹');
			});
		}
		
		if (replayBtn) {
			replayBtn.addEventListener('click', () => {
				console.log('å›æ”¾å¯¹è¯');
				// è¿™é‡Œå¯ä»¥æ·»åŠ å›æ”¾å¯¹è¯çš„é€»è¾‘
				showChatMessage('ç³»ç»Ÿ', 'å¼€å§‹å›æ”¾å†å²å¯¹è¯');
			});
		}
		
		if (pauseBtn) {
			pauseBtn.addEventListener('click', () => {
				console.log('æš‚åœå¯¹è¯');
				// è¿™é‡Œå¯ä»¥æ·»åŠ æš‚åœå¯¹è¯çš„é€»è¾‘
				showChatMessage('ç³»ç»Ÿ', 'å¯¹è¯å·²æš‚åœ');
			});
		}
		
		if (stopBtn) {
			stopBtn.addEventListener('click', () => {
				console.log('åœæ­¢å¯¹è¯');
				// è¿™é‡Œå¯ä»¥æ·»åŠ åœæ­¢å¯¹è¯çš„é€»è¾‘
				showChatMessage('ç³»ç»Ÿ', 'å¯¹è¯å·²åœæ­¢');
			});
		}
		
		if (clearBtn) {
			clearBtn.addEventListener('click', () => {
				console.log('æ¸…é™¤å¯¹è¯');
				// æ¸…é™¤èŠå¤©è®°å½•
				const chatMessages = document.getElementById('chatMessages');
				if (chatMessages) {
					chatMessages.innerHTML = '<div class="chat-message"><div class="agent-name">ç³»ç»Ÿ</div><div class="message-content">å¯¹è¯è®°å½•å·²æ¸…é™¤</div><div class="timestamp">åˆšåˆš</div></div>';
				}
			});
		}
	}
	
	// æ˜¾ç¤ºèŠå¤©æ¶ˆæ¯çš„è¾…åŠ©å‡½æ•°
	function showChatMessage(sender, message) {
		const chatMessages = document.getElementById('chatMessages');
		if (chatMessages) {
			const messageDiv = document.createElement('div');
			messageDiv.className = 'chat-message';
			messageDiv.innerHTML = `
				<div class="agent-name">${sender}</div>
				<div class="message-content">${message}</div>
				<div class="timestamp">åˆšåˆš</div>
			`;
			chatMessages.appendChild(messageDiv);
			chatMessages.scrollTop = chatMessages.scrollHeight;
		}
	}
	
	// æ¸…é™¤å¯¹è¯è®°å½•çš„å‡½æ•°
	function clearChatMessages() {
		const chatMessages = document.getElementById('chatMessages');
		if (chatMessages) {
			// æ¸…é™¤æ‰€æœ‰æ¶ˆæ¯ï¼Œåªä¿ç•™æ¬¢è¿æ¶ˆæ¯
			chatMessages.innerHTML = `
				<div class="chat-message" style="background: rgba(76, 175, 80, 0.15); border-left: 3px solid #4CAF50; margin-bottom: 15px;">
					<div class="agent-name" style="color: #4CAF50; font-size: 15px; font-weight: 700;">ğŸ’¬ ç³»ç»Ÿæ¶ˆæ¯</div>
					<div class="message-content" style="color: rgba(255, 255, 255, 0.95); font-size: 14px; line-height: 1.6; margin-top: 8px;">å¯¹è¯è®°å½•å·²æ¸…é™¤ï¼Œç­‰å¾…æ–°çš„å¯¹è¯å†…å®¹...</div>
					<div class="timestamp" style="color: rgba(255, 255, 255, 0.6); font-size: 12px; margin-top: 8px;">${new Date().toLocaleTimeString('zh-CN')}</div>
				</div>
			`;
			
			// æ¸…é™¤é‡å¤æ¶ˆæ¯è®°å½•
			lastMessages = {};
			
			console.log('å¯¹è¯è®°å½•å·²æ¸…é™¤');
		}
	}
</script>
